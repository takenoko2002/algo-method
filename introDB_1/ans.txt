#1-1
select * from prefectures;

#1-2
select id,name as '都道府県名' from prefectures;

#1-3
select * from prefectures where population < 1000000;

#1-4
select * from prefectures order by area desc limit 10;

#1-5
select * from prefectures where name like '%島%';

#1-6
select max(highest) as '最高気温',min(lowest) as '最低気温' from temperature_august;

#1-7
-----------------------------------------------------------------------------------------------------------------------------------------------------------
ヒント 2. ORDER BY の落とし穴
AS 句で名前を指定したカラムでデータをソートする場合は注意が必要です。 たとえば、次のクエリは都道府県データを人口が少ない順に表示することを想定したクエリですが、
これは正しく動作しません。

SELECT name, population AS '人口' FROM prefectures ORDER BY '人口'
正しく動作させるためには、ORDER BY 句で用いられるカラム名は「`」で囲う必要があります。
SELECT name, population AS '人口' FROM prefectures ORDER BY `人口`
-----------------------------------------------------------------------------------------------------------------------------------------------------------
select id,name as '都道府県名',population / area as '人口密度' from prefectures order by `人口密度` desc;

#2-1
-----------------------------------------------------------------------------------------------------------------------------------------------------------
副問い合わせ文の中に ; はつけません。
複数の中のいずれかという条件をつけたい時には、WHERE 節の中で IN を使うとよいです。
-----------------------------------------------------------------------------------------------------------------------------------------------------------
select * from prefectures where name IN (select name from kanto_regions);

#2-2
SELECT  region AS '地方名' ,COUNT(*) AS '都道府県数', SUM(area) AS '総面積' FROM prefectures GROUP BY region order by `総面積` desc;

#2-3
UPDATE prefectures SET name = '茨城県' WHERE name = '茨木県';
UPDATE prefectures SET name = '鳥取県' WHERE name = '取鳥県';
SELECT * FROM prefectures;

#2-4
INSERT INTO prefectures VALUES (36, '徳島県', 4146, 720000);
INSERT INTO prefectures VALUES (37, '香川県', 1876, 950000);
INSERT INTO prefectures VALUES (38, '愛媛県', 5675, 1335000);
INSERT INTO prefectures VALUES (39, '高知県', 7102, 692000);

SELECT * FROM prefectures order by id;

#2-5
DELETE FROM prefectures WHERE id == 0 OR id >= 48;
SELECT * FROM prefectures;


#2-6
-----------------------------------------------------------------------------------------------------------------------------------------------------------
GROUP BY 句を用いて集計したデータに対して検索を行うには、HAVING 句を用います。
WHERE 句は集計前のデータの検索を行い、HAVING 句は集計後のデータの検索を行うことに注意してください。
-----------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT name AS '顧客名',sum(amount) AS '合計金額' FROM ledger WHERE date BETWEEN '2022-08-08' AND '2022-08-14' group by name having sum(amount) >= 5000;

#2-7
-----------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT 句の内部に副問い合わせ文を書くことで地方名を取得する。
-----------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT name AS "都道府県名", (SELECT name FROM regions WHERE regions.id = prefectures.region_id) AS "地方名" FROM prefectures;

#3-1
-----------------------------------------------------------------------------------------------------------------------------------------------------------
テーブルにおけるデータの取得開始位置を取得するには OFFSET 句を使います。
11件目以降のデータを出力する際には OFFSET の値は 11 ではなく 10 であること(0オリジン)、OFFSET 句は LIMIT 句の後ろに書くことに注意してください。
-----------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT * FROM prefectures ORDER BY area DESC LIMIT 1 OFFSET 1 ;


#3-2
-----------------------------------------------------------------------------------------------------------------------------------------------------------
WITH 句とは、副問い合わせに名前をつける機能のことです。
次のようなメリットがあります。
・コードの見通しが良くなる (一般的なプログラミングで変数を用いるのと似た感覚です)
・長い SELECT 文を共通化し、クエリの見通しをよくすることができる
・そのあとのクエリ内で何度でも使い回すことができる
-----------------------------------------------------------------------------------------------------------------------------------------------------------
-- 内陸県を取得する SELECT 文のサブクエリ作成
WITH
    inland_prefectures
AS (
    -- ここに適切なクエリを記述してください
    SELECT * FROM prefectures WHERE name IN ('栃木県', '群馬県', '埼玉県', '山梨県','長野県', '岐阜県', '滋賀県', '奈良県')
)
-- 内陸県のデータを面積が大きい順に表示
SELECT
    *
FROM
    inland_prefectures
ORDER BY
    area DESC;

#3-3
-----------------------------------------------------------------------------------------------------------------------------------------------------------
SQL文の中で条件分岐を行うには CASE 式を使います。
偶奇判定を行うには以下のような文となる。
SELECT CASE WHEN id%2 = 0 THEN '偶数' ELSE '奇数' END AS '偶奇' FROM xxxxx;
-----------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT *,
CASE
WHEN score BETWEEN 90 AND 100 THEN '秀' 
WHEN score BETWEEN 80 AND 89  THEN '優'
WHEN score BETWEEN 65 AND 79  THEN '良'
WHEN score BETWEEN 50 AND 64  THEN '可'
ELSE '不可'
END AS '評価' FROM grades;

#3-4
-----------------------------------------------------------------------------------------------------------------------------------------------------------
GROUP BY 句に結果のカラムを指定することで条件分岐の結果にしたがってグループ化することができる。
-----------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT
CASE WHEN age BETWEEN 0 AND 14  THEN '年少人口' 
WHEN age BETWEEN 15 AND 64 THEN '生産年齢人口' 
WHEN age >= 64  THEN '老年人口'
END AS '年齢3区分',
SUM(total) AS '総人口'
FROM population
GROUP BY `年齢3区分`;

#3-5
-----------------------------------------------------------------------------------------------------------------------------------------------------------
複数のクエリの結果をひとまとめにしたいときには UNION ALL 演算子を使います。
-----------------------------------------------------------------------------------------------------------------------------------------------------------
WITH
    UNION_TABLE
AS 
(
    SELECT * FROM expenses_april
    UNION ALL
    SELECT * FROM expenses_may
    UNION ALL
    SELECT * FROM expenses_june
)


SELECT category AS "カテゴリ",SUM(amount) AS '支出額' FROM UNION_TABLE 
GROUP BY `カテゴリ`
ORDER BY
    `支出額` DESC;

#3-6
-----------------------------------------------------------------------------------------------------------------------------------------------------------
複数のクエリの結果から重複したレコードだけを抽出したいときには INTERSECT 演算子を使う。
INTERSECT で結ばれた複数のクエリは、実行結果のフォーマット (カラムの数や順番、それぞれのデータ型) が一致していないといけない。
-----------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT email FROM registrations_day1
INTERSECT
SELECT email FROM registrations_day2
INTERSECT
SELECT email FROM registrations_day3;

#3-7
-----------------------------------------------------------------------------------------------------------------------------------------------------------
複数のクエリの結果から差分を抽出したいときには EXCEPT 演算子を使う。
EXCEPT で結ばれた複数のクエリは、実行結果のフォーマット (カラムの数や順番、それぞれのデータ型) が一致していないといけない。
-----------------------------------------------------------------------------------------------------------------------------------------------------------
WITH
    except_table
AS 
(
    SELECT email,game_id,score FROM results
    EXCEPT
    SELECT email,game_id,score FROM optout
)

SELECT email FROM except_table
GROUP BY email
ORDER BY
      SUM(score) DESC
LIMIT 10;

#4-1
select * from users where name like '%RURU' AND rank IS null AND flg_data_public = 1 ;

#4-2
-----------------------------------------------------------------------------------------------------------------------------------------------------------
条件付き COUNT
-----------------------------------------------------------------------------------------------------------------------------------------------------------
